/**
 * Copyright (C) 2015-2019 unfacd works
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <main.h>
#include <state_command_controller.h>
#include <fence.h>
#include <ufsrv_core/fence/fence_state.h>
#include <ufsrv_core/fence/fence_utils.h>
#include <fence_proto.h>
#include <ufsrv_core/user/user_backend.h>
#include <ufsrv_core/user/users_protobuf.h>
#include <ufsrvwebsock/include/protocol_websocket.h>
#include <ufsrvcmd_user_callbacks.h>
#include <ufsrvcmd_callbacks.h>
#include <ufsrv_core/msgqueue_backend/ufsrvcmd_broadcast.h>
#include <ufsrvuid.h>

extern ufsrv							*const masterptr;
extern __thread ThreadContext ufsrv_thread_context;

/**
 * 	@brief: StateCommand is generated by the sender(sesn_ptr_originator) to acknowledge a prior event by another user
 * 	in the same fence (sesn_ptr_target)
 */

#define _BUILD_COMMAND_CONTEXT() \
 StateCommandContext command_ctx = { \
         .command_base_context = { \
          .data_msg_ptr_received = data_msg_ptr_received, \
          .wsm_ptr_received = wsm_ptr_received, \
          .sesn_originator = { \
            .ctx_ptr = ctx_ptr, \
            .lock_state = false \
          } \
         } \
 }; \

inline static UFSRVResult *_CommandControllerStateTyping (InstanceContextForSession *, WebSocketMessage *wsm_ptr_received, DataMessage *data_msg_ptr);

inline static UFSRVResult *_MarshalStateForTyping(CommandBaseContext *cmd_base_ctx_ptr);

static UFSRVResult *_HandleStateCommandError (InstanceHolderForSession *, FenceStateDescriptor *fence_state_ptr, WebSocketMessage *wsm_ptr_received, DataMessage *data_msg_ptr_receivedinator, int rescode, int command_type);
static void	_BuildErrorHeaderForStateCommand (CommandHeader *header_ptr, CommandHeader *header_ptr_originator, int errcode, int command_type);


UFSRVResult *IsUserAllowedToGenerateState(CommandBaseContext *cmd_ctx, CommandMarshallerCallback command_marshaller, unsigned long call_flags);
UFSRVResult *IsUserAllowedToGenerateTypingState (InstanceHolderForSession *instance_sesn_ptr_sender, unsigned long uid_origintor, StateCommandContext *context_ptr);

struct MarshalMessageEnvelopeForState {
  UfsrvCommandWire		*ufsrv_command_wire;
  Envelope						*envelope;
  StateCommand 			  *state_command;
  CommandHeader 			*header;
  UserRecord					*user_record_originator;
};
typedef struct MarshalMessageEnvelopeForState MarshalMessageEnvelopeForState;

#define _GENERATE_STATE_COMMAND_ENVELOPE_INITIALISATION() \
	UfsrvCommandWire								ufsrv_command_wire	= UFSRV_COMMAND_WIRE__INIT;	\
	Envelope												command_envelope		=	ENVELOPE__INIT;	\
	StateCommand 									  state_command			  =	STATE_COMMAND__INIT;	\
	CommandHeader 									header							=	COMMAND_HEADER__INIT;	\
	\
	UserRecord											user_record_originator;	\
	\
	MarshalMessageEnvelopeForState	envelope_marshal = {	\
			.ufsrv_command_wire	=	&ufsrv_command_wire,	\
			.envelope						=	&command_envelope,	\
			.state_command		  =	&state_command,	\
			.header							=	&header,	\
			.user_record_originator	=	&user_record_originator	\
	}

inline static void _PrepareMarshalMessageForState (MarshalMessageEnvelopeForState *envelope_ptr, StateCommandContext *cmd_ctx_ptr, enum _StateCommand__CommandTypes, enum _CommandArgs command_arg);

inline static void
_PrepareMarshalMessageForState (MarshalMessageEnvelopeForState *envelope_ptr, StateCommandContext *cmd_ctx_ptr, enum _StateCommand__CommandTypes command_type, enum _CommandArgs command_arg)
{
  envelope_ptr->envelope->ufsrvcommand								=	envelope_ptr->ufsrv_command_wire;

  envelope_ptr->envelope->ufsrvcommand->statecommand		=	envelope_ptr->state_command;
  envelope_ptr->envelope->ufsrvcommand->ufsrvtype			=	UFSRV_COMMAND_WIRE__UFSRV_TYPE__UFSRV_STATE;
  envelope_ptr->envelope->ufsrvcommand->header				=	envelope_ptr->header;

  envelope_ptr->state_command->header									=	envelope_ptr->header;

  envelope_ptr->envelope->sourceufsrvuid							=	"0";
  envelope_ptr->envelope->timestamp										=	GetTimeNowInMillis(); envelope_ptr->envelope->has_timestamp = 1;

  envelope_ptr->header->when													=	envelope_ptr->envelope->timestamp; 	envelope_ptr->header->has_when = 1;
  envelope_ptr->header->cid														=	SESSION_ID(CMDCTX_SESN_ORIGINATOR(cmd_ctx_ptr)); 							envelope_ptr->header->has_cid = 1;
  envelope_ptr->header->command												=	command_type;
  envelope_ptr->header->args													=	command_arg;												envelope_ptr->header->has_args = 1;

  if (IS_PRESENT(CMDCTX_EVENT(cmd_ctx_ptr))) {
    envelope_ptr->header->when_eid										=	CMDCTX_EVENT(cmd_ctx_ptr)->when; 					envelope_ptr->header->has_when_eid = 1;
    envelope_ptr->header->eid													=	CMDCTX_EVENT(cmd_ctx_ptr)->eid; 					envelope_ptr->header->has_eid = 1;
  }

  if (IS_PRESENT(CMDCTX_DATA_MESSAGE(cmd_ctx_ptr))) {
    envelope_ptr->header->when_client								=	CMDCTX_DATA_MESSAGE(cmd_ctx_ptr)->ufsrvcommand->statecommand->header->when;
    envelope_ptr->header->has_when_client						=	CMDCTX_DATA_MESSAGE(cmd_ctx_ptr)->ufsrvcommand->statecommand->header->has_when_client = 1;
  }

}

/**
 * 	@brief: This is invoked in the context of wire data message arriving via the msgqueue bus. The message is in raw wire format (proto).
 * 	The session may or may not be connected to this ufsrv.
 *
 *	@param sesn_ptr_local_user: The user who sent this message, for whom a local Session has been found. This Session may be concurrently
 *	operated on by a Worker thread (in which case the lock on it will fail. However, in the context of this routine,
 *	it is operated on by a Ufsrv Worker Thread
 *
 * 	@param data_msg_ptr: The raw DataMessage protobuf as provided by the sending user. This message will have been previously verified
 * 	by the caller, being bearer of structurally valid  data
 *
 *	@locked sesn_ptr_local_user: must be locked by the caller
 * 	@locks: NONE directly, but downstream will, eg Fence
 * 	@unlocks NONE:
 */
UFSRVResult *
CommandCallbackControllerStateCommand (InstanceContextForSession *ctx_ptr_local_user, WebSocketMessage *wsm_ptr_received, DataMessage *data_msg_ptr)
{
  CommandHeader *command_header = data_msg_ptr->ufsrvcommand->statecommand->header;

  switch (command_header->command)
  {
    case STATE_COMMAND__COMMAND_TYPES__TYPING:
      _CommandControllerStateTyping(ctx_ptr_local_user, wsm_ptr_received, data_msg_ptr);
      break;

    default:
      syslog(LOG_DEBUG, "%s {pid:'%lu', o:'%p', command:'%d'}: RECEIVED UNKNOWN STATE COMMAND", __func__, pthread_self(), ctx_ptr_local_user->sesn_ptr, command_header->command);
  }

  if (IS_PRESENT(wsm_ptr_received)) {
    UfsrvCommandInvokeUserCommand(ctx_ptr_local_user, NULL, wsm_ptr_received, NULL, NULL, uOK_V1_IDX);
  }

  exit_release:
  return SESSION_RESULT_PTR(ctx_ptr_local_user->sesn_ptr);

  exit_ufsrvuid_error:
  syslog(LOG_DEBUG, "%s (pid:'%lu', o:'%p', cid:'%lu', command:'%d'): ERROR: UFSRVUID WAS NOT DEFINED ", __func__, pthread_self(), ctx_ptr_local_user->sesn_ptr, SESSION_ID(ctx_ptr_local_user->sesn_ptr), command_header->command);
  _RETURN_RESULT_SESN(ctx_ptr_local_user->sesn_ptr, NULL, RESULT_TYPE_ERR, RESCODE_PROG_NULL_POINTER)
}

/**
 * 	@brief: This function is designed to work with ephemeral sessions, not io sessions through the main loop.
 *
 *	@param sesn_ptr:	Target session loaded in ephemeral mode
 * 	@locked RW sesn_ptr: must be locked by the caller
 * 	@locks RW f_ptr: issues flags to cause locking
 * 	@unlocks f_ptr:
 */
inline static UFSRVResult *
_CommandControllerStateTyping (InstanceContextForSession *ctx_ptr, WebSocketMessage *wsm_ptr_received, DataMessage *data_msg_ptr_received)
{
  _BUILD_COMMAND_CONTEXT();

  StateCommand			  *cmd_ptr = data_msg_ptr_received->ufsrvcommand->statecommand;

  if (cmd_ptr->fid > 0) { // && UfsrvUidGetSequenceId((const UfsrvUid *)cmd_ptr->uid_originator.data) > 0) {
    command_ctx.fid = cmd_ptr->fid;
    IsUserAllowedToGenerateState(COMMAND_BASE_CONTEXT(&command_ctx), _MarshalStateForTyping, CALLFLAGS_EMPTY);

    if (SESSION_RESULT_TYPE_ERROR(ctx_ptr->sesn_ptr)) {
     // _HandleStateCommandError (ctx_ptr->instance_sesn_ptr, NULL, wsm_ptr_received, data_msg_ptr, SESSION_RESULT_CODE(ctx_ptr->sesn_ptr), data_msg_ptr->ufsrvcommand->statecommand->header->command);

      _RETURN_RESULT_SESN(ctx_ptr->sesn_ptr, NULL, RESULT_TYPE_ERR, RESCODE_PROG_NULL_POINTER)
    }

    return SESSION_RESULT_PTR(ctx_ptr->sesn_ptr);
  }

  _RETURN_RESULT_SESN(ctx_ptr->sesn_ptr, NULL, RESULT_TYPE_ERR, RESCODE_PROG_NULL_POINTER)
}

/**
 * 	@brief: .
 *
 * 	@param data_msg_ptr: is the original wire message sent by the client. We'll have to copy bits and pieces from  it for this transmission
 *  @locked f_ptr (as contained in FenceStateDescriptor in CallContext):
 *  @locked sesn_ptr (context_ptr->sesn_ptr->caller):
 *  @locked context_ptr->sesn_ptr->called
 *	@unlocks: none
 *  @dynamic_memory fence_records_ptr: array of FenceRecord initiated with dynamic values. Must be freed with DestructFenceRecordProto (FenceRecord **fence_records_ptr, unsigned count)
 */
inline static UFSRVResult *
_MarshalStateForTyping (CommandBaseContext *cmd_base_ctx_ptr)
{
  StateCommandContext *cmd_ctx_ptr = (StateCommandContext *)cmd_base_ctx_ptr;
  StateCommand *cmd_ptr_received = CMDCTX_DATA_MESSAGE(cmd_ctx_ptr)->ufsrvcommand->statecommand;

  _GENERATE_STATE_COMMAND_ENVELOPE_INITIALISATION();

  _PrepareMarshalMessageForState (&envelope_marshal, cmd_ctx_ptr, STATE_COMMAND__COMMAND_TYPES__TYPING, COMMAND_ARGS__SYNCED);
  MakeUfsrvUidInProto(&SESSION_UFSRVUIDSTORE(CMDCTX_SESN_ORIGINATOR(cmd_ctx_ptr)), &(state_command.uid_originator), true);
  state_command.has_uid_originator  = 1;
  state_command.fid                 = cmd_ptr_received->fid; state_command.has_fid = 1;
  state_command.type                = cmd_ptr_received->type;
  state_command.state               = cmd_ptr_received->state;

  UfsrvCommandMarshallingDescriptor ufsrv_description = {header.eid, CMDCTX_STATE_FID(cmd_ctx_ptr), header.when, &EnvelopeMetaData, &command_envelope};
  UfsrvCommandInvokeUserCommand(CMDCTX_SESN_CTX_ORIGINATOR(cmd_ctx_ptr), CMDCTX_STATE_TARGET_SESN_CTX(cmd_ctx_ptr),
          IS_PRESENT(CMDCTX_WSM(cmd_ctx_ptr))?CMDCTX_WSM(cmd_ctx_ptr):&(WebSocketMessage){.type=WEB_SOCKET_MESSAGE__TYPE__REQUEST, .request=NULL},
          NULL, &ufsrv_description, uSTATE_V1_IDX);

  _RETURN_RESULT_SESN(CMDCTX_SESN_ORIGINATOR(cmd_ctx_ptr), NULL, RESULT_TYPE_SUCCESS, RESCODE_PROG_NULL_POINTER)

}

/////////////////////////////////////////////

/**
 * 	@brief: Generalised command sending
 */
inline static UFSRVResult *
_MarshalCommandToUser	(InstanceHolderForSession *instance_sesn_ptr, InstanceHolderForSession *instance_sesn_ptr_target, Fence *f_ptr, WebSocketMessage *wsm_ptr_received, Envelope *command_envelope_ptr, unsigned req_cmd_idx)
{
  Session *sesn_ptr = SessionOffInstanceHolder(instance_sesn_ptr);
  Session *sesn_ptr_target = IS_PRESENT(instance_sesn_ptr_target)?SessionOffInstanceHolder(instance_sesn_ptr_target):NULL;

  CommandHeader *command_header_ptr	=	command_envelope_ptr->ufsrvcommand->header;

  UfsrvCommandMarshallingDescriptor ufsrv_description = {command_header_ptr->eid, IS_PRESENT(f_ptr) ? FENCE_ID(f_ptr) : 0, command_header_ptr->when, &EnvelopeMetaData, command_envelope_ptr};

#ifdef __UF_TESTING
  syslog (LOG_DEBUG, "%s {pid:'%lu', o:'%p', cid:'%lu', cid_target:'%lu', uname_target:'%s', fid:'%lu'} Marshaling command... ", __func__, pthread_self(), sesn_ptr, SESSION_ID(sesn_ptr),
          SESSION_ID((sesn_ptr_target?sesn_ptr_target:sesn_ptr)), SESSION_USERNAME((sesn_ptr_target?sesn_ptr_target:sesn_ptr)), IS_PRESENT(f_ptr)?FENCE_ID(f_ptr):0);
#endif

  UfsrvCommandInvokeUserCommand(&(InstanceContextForSession) {instance_sesn_ptr, sesn_ptr},
                                (IS_PRESENT(instance_sesn_ptr_target) ? (&(InstanceContextForSession) {
                                        instance_sesn_ptr_target, sesn_ptr_target}) : NULL),
                                wsm_ptr_received, NULL, &ufsrv_description, req_cmd_idx);

  _RETURN_RESULT_SESN(sesn_ptr, NULL, RESULT_TYPE_SUCCESS, RESCODE_PROG_NULL_POINTER)

}

/*
 * @param errcode: should reflect a UFSRVResult.rescode type
 * @param command_type: should reflect a protobif command type, or -1 to re use original
 *
 */
static void
_BuildErrorHeaderForStateCommand (CommandHeader *header_ptr, CommandHeader *header_ptr_originator, int errcode, int command_type)
{
  switch (errcode)
  {
    case RESCODE_FENCE_EXISTS:
      header_ptr->args_error	=	FENCE_COMMAND__ERRORS__ALREADY_EXISTS; 	header_ptr->has_args_error	=	1;
      header_ptr->args				=	COMMAND_ARGS__REJECTED;									header_ptr->has_args				=	1;
      break;

    case RESCODE_FENCE_FENCE_MEMBERSHIP:
      header_ptr->args_error	=	FENCE_COMMAND__ERRORS__NOT_MEMBER; 			header_ptr->has_args_error	=	1;
      header_ptr->args				=	COMMAND_ARGS__REJECTED;									header_ptr->has_args				=	1;
      break;

    case RESCODE_USER_SHARELIST_PRESENT:
      header_ptr->args_error	=	STATE_COMMAND__ERRORS__NOT_ON_SHARELIST; 			header_ptr->has_args_error	=	1;
      header_ptr->args				=	COMMAND_ARGS__REJECTED;									header_ptr->has_args				=	1;
      break;

    case RESCODE_FENCE_OWNERSHIP:
      header_ptr->args_error	=	FENCE_COMMAND__ERRORS__PERMISSIONS_ADMIN; 	header_ptr->has_args_error	=	1;
      header_ptr->args				=	COMMAND_ARGS__REJECTED;											header_ptr->has_args				=	1;
      break;

    case RESCODE_FENCE_DOESNT_EXIST:
      header_ptr->args_error	=	FENCE_COMMAND__ERRORS__GROUP_DOESNT_EXIST; 	header_ptr->has_args_error	=	1;
      header_ptr->args				=	COMMAND_ARGS__REJECTED;											header_ptr->has_args				=	1;
      break;

      //command parameter empty, for example missing fence name
    case RESCODE_PROG_MISSING_PARAM:
      header_ptr->args_error	=	FENCE_COMMAND__ERRORS__MISSING_PARAMETER; 	header_ptr->has_args_error	=	1;
      header_ptr->args				=	COMMAND_ARGS__REJECTED;											header_ptr->has_args				=	1;
      break;

    default:
      goto exit_error;
  }

  if (command_type > 0)		header_ptr->command	=	command_type;
  else									header_ptr->command	=	header_ptr_originator->command;//restore original command
  header_ptr->when_client	=	header_ptr_originator->when;							header_ptr->has_when_client=header_ptr_originator->has_when_client;
  return;

  exit_error:
  return;

}

/**
 * 	@brief: Marshal an error response message to user. This is invoked in the context of command processing.
 * 	@data_msg_ptr: the original wire command that triggered the error as packaged by user
 * 	@locked f_ptr: f_ptr
 * 	@locked sesn_ptr:
 * 	@unlocks: none
 */
__unused static UFSRVResult *
_HandleStateCommandError (InstanceHolderForSession *instance_sesn_ptr, FenceStateDescriptor *fence_state_ptr, WebSocketMessage *wsm_ptr_received, DataMessage *data_msg_ptr_received, int rescode, int command_type)
{
  Envelope 					command_envelope	= ENVELOPE__INIT;
  CommandHeader 		header						= COMMAND_HEADER__INIT;
  UfsrvCommandWire	ufsrv_command			= UFSRV_COMMAND_WIRE__INIT;
  StateCommand 		State_command		= STATE_COMMAND__INIT;

  Session           *sesn_ptr         = SessionOffInstanceHolder(instance_sesn_ptr);

  command_envelope.ufsrvcommand				=	&ufsrv_command;
  ufsrv_command.header								=	&header;
  State_command.header							=	&header;

  ufsrv_command.statecommand				=	&State_command;
  ufsrv_command.ufsrvtype							=	UFSRV_COMMAND_WIRE__UFSRV_TYPE__UFSRV_RECEIPT;

  if (IS_PRESENT(fence_state_ptr)) {
    State_command.fid								=	 FENCE_ID(FENCESTATE_FENCE(fence_state_ptr));
    State_command.has_fid           = 1;
  } else {
    State_command.fid               = data_msg_ptr_received->ufsrvcommand->statecommand->fid;
    State_command.has_fid           = data_msg_ptr_received->ufsrvcommand->statecommand->has_fid;
  }

  command_envelope.sourceufsrvuid			=	"0";
  command_envelope.timestamp					=	GetTimeNowInMillis(); command_envelope.has_timestamp=1;

  header.when													=	command_envelope.timestamp; header.has_when		=	1;
  header.cid													=	SESSION_ID(sesn_ptr);				header.has_cid		=	1;

  _BuildErrorHeaderForStateCommand (&header, data_msg_ptr_received->ufsrvcommand->statecommand->header, rescode, command_type);

#ifdef __UF_TESTING
  syslog(LOG_DEBUG, "%s {pid:'%lu', o:'%p', uid:'%lu', cid:'%lu', arg_error:'%d', rescode:'%d'}: Marshaling Error response message...", __func__, pthread_self(), sesn_ptr, SESSION_USERID(sesn_ptr), SESSION_ID(sesn_ptr), header.args_error, rescode);
#endif

  return (_MarshalCommandToUser(instance_sesn_ptr, NULL,  IS_PRESENT(fence_state_ptr)?FENCESTATE_FENCE(fence_state_ptr):NULL, wsm_ptr_received, &command_envelope,  uSETACCOUNT_ATTRS_V1_IDX));

}

/**
 *  For a user(sender) to generate a receipt to another user(originator):
 *  1)sender musn't be on originator's blocked list, 2)originator must be on sender's sharelist for ReadState
 *  Also, since ReadStates are bound to fences, both users need to be members of the given fence.
 *	@param sesn_ptr_sender: the user who is generating the State
 * 	@locked sesn_ptr_sender
 * 	@locks f_ptr:
 * 	@locks sesn_ptr_originator: the user who sent the original message for which current receipt is being processed
 * 	@unlocks f_ptr: on error
 * 	@unlocks sesn_ptr_originator: on error or just before exit
 */
UFSRVResult *
IsUserAllowedToGenerateState (CommandBaseContext *cmd_base_ctx, CommandMarshallerCallback command_marshaller, unsigned long call_flags)
{
  StateCommandContext *cmd_ctx = (StateCommandContext *)cmd_base_ctx;

  Fence			*f_ptr							    = NULL;
  unsigned long sesn_call_flags	=	(CALL_FLAG_LOCK_SESSION|CALL_FLAG_LOCK_SESSION_BLOCKING|
                                     CALL_FLAG_HASH_SESSION_LOCALLY|CALL_FLAG_HASH_UID_LOCALLY| CALL_FLAG_HASH_USERNAME_LOCALLY|
                                     CALL_FLAG_ATTACH_FENCE_LIST_TO_SESSION|CALL_FLAG_REMOTE_SESSION);

  unsigned long fence_call_flags_final = FENCE_CALLFLAG_SEARCH_BACKEND|FENCE_CALLFLAG_HASH_FENCE_LOCALLY|FENCE_CALLFLAG_ATTACH_USER_LIST_TO_FENCE|FENCE_CALLFLAG_KEEP_FENCE_LOCKED|FENCE_CALLFLAG_LOCK_FENCE_BLOCKING;

  FindFenceById(CMDCTX_SESN_ORIGINATOR(cmd_ctx), cmd_ctx->fid, fence_call_flags_final);
  InstanceHolderForFence *instance_f_ptr = (InstanceHolderForFence *)SESSION_RESULT_USERDATA(CMDCTX_SESN_ORIGINATOR(cmd_ctx));

  if (IS_EMPTY(instance_f_ptr)) {
    if (SESSION_RESULT_CODE_EQUAL(CMDCTX_SESN_ORIGINATOR(cmd_ctx), RESCODE_FENCE_DOESNT_EXIST) || SESSION_RESULT_CODE_EQUAL(CMDCTX_SESN_ORIGINATOR(cmd_ctx), RESCODE_BACKEND_RESOURCE_NULL)) {
      _RETURN_RESULT_SESN(CMDCTX_SESN_ORIGINATOR(cmd_ctx), NULL, RESULT_TYPE_ERR, RESCODE_FENCE_DOESNT_EXIST)
    }
    else 	SESSION_RETURN_RESULT(CMDCTX_SESN_ORIGINATOR(cmd_ctx), NULL, RESULT_TYPE_ERR, SESSION_RESULT_CODE(CMDCTX_SESN_ORIGINATOR(cmd_ctx)))
  }

  bool fence_lock_already_owned = (SESSION_RESULT_CODE_EQUAL(CMDCTX_SESN_ORIGINATOR(cmd_ctx), RESCODE_PROG_LOCKED_BY_THIS_THREAD));

  f_ptr = FenceOffInstanceHolder(instance_f_ptr);

  //>>> Fence RW LOCKED

  InstanceHolderForFenceStateDescriptor *instance_fstate_ptr_sender;
  __unused InstanceHolderForFenceStateDescriptor *instance_fstate_ptr_originator;

#define FLAG_FENCE_LOCK_FALSE false

  if (!IS_PRESENT((instance_fstate_ptr_sender = IsUserMemberOfThisFence(&(SESSION_FENCE_LIST(CMDCTX_SESN_ORIGINATOR(cmd_ctx))), f_ptr, FLAG_FENCE_LOCK_FALSE)))) {
    if (!fence_lock_already_owned)	FenceEventsUnLockCtx(THREAD_CONTEXT_PTR, f_ptr, SESSION_RESULT_PTR(CMDCTX_SESN_ORIGINATOR(cmd_ctx)));

    _RETURN_RESULT_SESN(CMDCTX_SESN_ORIGINATOR(cmd_ctx), NULL, RESULT_TYPE_ERR, RESCODE_USER_FENCE_ALREADYIN)
  }

  //TODO: check sesn_ptr_called prefs whilst session is locked allow/disallow event

  FenceRawSessionList raw_session_list = {0};
  GetRawMemberUsersListForFence (CMDCTX_SESN_ORIGINATOR(cmd_ctx), instance_f_ptr, FENCE_CALLFLAG_INCLUDE_REMOTE_SESSIONS, &raw_session_list);//no locking
  if (!fence_lock_already_owned)	FenceEventsUnLockCtx(THREAD_CONTEXT_PTR, f_ptr, SESSION_RESULT_PTR(CMDCTX_SESN_ORIGINATOR(cmd_ctx)));

  if (raw_session_list.sessions_sz > 0) {
    for (size_t i = 0; i < raw_session_list.sessions_sz; i++) {
      Session *sesn_ptr_listed = SessionOffInstanceHolder(raw_session_list.sessions[i]);
      if (SESSION_ID(CMDCTX_SESN_ORIGINATOR(cmd_ctx)) == SESSION_ID(sesn_ptr_listed)) continue; //skip self

      if (IsUserOnShareListBlocked(sesn_ptr_listed, CMDCTX_SESN_ORIGINATOR(cmd_ctx))) {
        syslog (LOG_ERR, "%s {pid:'%lu', o:'%p', cid:'%lu', o_blocking:'%p', cid_blocked:'%lu'} ERROR: BLOCKED BY USER...", __func__, pthread_self(), CMDCTX_SESN_ORIGINATOR(cmd_ctx), SESSION_ID(CMDCTX_SESN_ORIGINATOR(cmd_ctx)), sesn_ptr_listed, SESSION_ID(sesn_ptr_listed));
        continue;
      }

      //  if (!(*GetShareListPresenceChecker(SHARELIST_READ_RECEIPT))(CMDCTX_SESN_ORIGINATOR(cmd_ctx), CMDCTX_SESN_ORIGINATOR(cmd_ctx))) {
//    _RETURN_RESULT_SESN(CMDCTX_SESN_ORIGINATOR(cmd_ctx), NULL, RESULT_TYPE_ERR, RESCODE_USER_SHARELIST_PRESENT)
//  }

      if (IS_PRESENT(command_marshaller)) {
        CMDCTX_STATE_TARGET_SESN_CTX(cmd_ctx) = &(InstanceContextForSession){raw_session_list.sessions[i], sesn_ptr_listed};
        INVOKE_COMMAND_MARSHALLER(command_marshaller, COMMAND_BASE_CONTEXT(cmd_ctx));
      }
    }

    DestructFenceRawSessionList (&raw_session_list, false);
  }

  return_success:

  _RETURN_RESULT_SESN(CMDCTX_SESN_ORIGINATOR(cmd_ctx), NULL, RESULT_TYPE_SUCCESS, RESCODE_BACKEND_RESOURCE_UPDATED)

}